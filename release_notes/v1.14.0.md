# WhisperDoc Technical Release Notes - v1.14.0
**Version Range: v1.5.0 to v1.14.0**

This release marks the transition from a terminal-based interface to a production-ready Flutter desktop application, incorporating deep Win32 integration and a modular feature-sliced architecture.

## Core Features & Infrastructure

### Flutter Desktop Implementation
- Native Windows desktop client built using Flutter, utilizing a service-based architecture for high-performance audio processing.
- Implementation of real-time audio streaming via WebSockets with persistent session handling.
- Integration of the `record` package for raw PCM capture (16kHz, 16-bit Mono) optimized for minimal latency.
- Developed a comprehensive system-level glassmorphic interface to handle dense data visualization and control.

### Win32 Automation & Clipboard Integration
- Replaced standard Flutter clipboard operations with direct Win32 API calls (`GlobalAlloc`, `SetClipboardData`) for near-instantaneous transcription-to-paste performance.
- Implemented `SendInput`-based Ctrl+V simulation with proactive modifier key force-release to prevent keyboard state desynchronization.
- Added foreground window detection to selectively skip paste simulation when the application itself has focus, ensuring system stability.
- Migrated keyboard simulation from virtual keys to hardware scan codes to eliminate conflicts with the Flutter HardwareKeyboard state tracker.

### Hotkey Management & Resilience
- Overhauled the hotkey listener from a `Timer.periodic` polling mechanism to a native `GetMessage` blocking loop within a dedicated hardware isolate.
- Implemented an immutable isolate pattern, where the hardware isolate is respawned upon configuration changes to ensure state purity.
- Enhanced system resilience by ensuring hotkey stability across system sleep/idle states and handling Windows Error 1409 (hotkey already registered) via proactive unregistration hooks.

### Advanced Logging & History Systems
- Developed an in-app terminal-grade log viewer utilizing `SelectableText.rich` for granular inspection of system events.
- Implemented a circular log buffer (200-entry capacity) with stream-based emission for real-time UI consumption.
- Introduced a Transcription History system with a 50-entry memory limit to prevent bloat while maintaining user accessibility.
- Added "Incognito Mode" (Ghost Mode) logic that purges sensitive transcription buffers and prevents history persistence during active sessions.

## Architectural Changes

### Phase 5 Feature-Sliced Refactor
- Migrated from a monolithic screen-based approach to a feature-sliced architecture, enforcing strict boundaries between core services and UI features.
- Implemented a controller-based state management pattern where `ChangeNotifier` controllers serve as the single source of truth, decoupled from UI-specific logic.
- Adopted the `get_it` service locator pattern for dependency injection across the entire application lifecycle.
- Standardized service-to-UI communication using a proactive notification system that eliminates redundant widget rebuilds.

### WebSocket Protocol Optimization
- Established a versioned 'hello' handshake event for robust client-server identification and feature synchronization.
- Implemented session-based lazy connections with an automated 5-minute idle timeout to conserve server and network resources.
- Standardized server responses into typed JSON objects with specific error codes (e.g., `NO_AUDIO`, `MODEL_LOADING`) for resilient client-side error handling.
- Introduced exponential backoff strategy for reconnections (intervals scaling up to 30 seconds) to handle server-side maintenance or network instability.

## Performance & Build Engineering

### Docker Infrastructure Hardening
- Implemented a multi-stage Docker build strategy (builder/runner pattern) to isolate build-time dependencies and minimize the production footprint.
- Optimized Docker layer caching by prioritizing large, stable AI libraries (PyTorch, Whisper) in the build sequence.
- Integrated `malloc_trim` via `ctypes` to force OS-level memory reclamation after resource-heavy model unloading operations.
- Configured a read-only root filesystem for the backend container, utilizing `tmpfs` mounts for temporary audio assets to enhance security and performance.

### Windows Deployment Pipeline
- Standardized the Windows build pipeline using Inno Setup for automated, x64-exclusive installer generation.
- Configured native PE metadata rebranding (InternalName, OriginalFilename) to ensure correct identity in Task Manager and OS shell.
- Enabled native support for obfuscated Flutter builds and split-debug-info maps for secured production distribution.
- Hardened the `CMakeLists.txt` and native `main.cpp` configurations to match enterprise system-level identifiers and class naming.
